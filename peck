#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # shellcheck disable=SC2154,SC2034

  if [[ -e /tmp/peck/recording ]]; then
    pkill -INT -x wf-recorder
    rm /tmp/peck/recording
    exit 0
  fi

  # Clean old tmp files
  rm -rf /tmp/peck/out

  # Determine whether we are in record or screenshot mode
  if [[ "${args[--record]}" == "1" ]]; then
    mode="record"
  else
    mode="screenshot"
  fi

  # Determine whether we will keep the output file in tmp or move it to a permanent location
  if [[ "${args[--temp]}" == "1" ]]; then
    if [[ -n "${args[filepath]}" ]]; then
      notify_user "Invalid usage: --temp flag cannot be used when providing a filepath."
  	  exit 1
    fi
    mode_save="temporary"
  else
    mode_save="permanent"
  fi

  # Clipboard
  if [[ "${args[--clipboard]}" == "1" ]]; then
    copy_to_clipboard="true"
  else
    copy_to_clipboard="false"
  fi

  # Format

  arg_format="${args[--format]}"

  if [[ -n "$arg_format" ]]; then
    out_format="$arg_format"
  elif [[ "$mode" == "record" ]]; then
    out_format="$PECK_RECORDING_FORMAT"
  else
    out_format="$PECK_SCREENSHOT_FORMAT"
  fi

  # Path

  filepath="${args[filepath]}"
  timestamp="$(date +%Y-%m-%d_%H-%M-%S)"

  if [[ -n "$filepath" ]]; then
    # Check if filepath ends with a slash
    if [[ "$filepath" == */ ]]; then
      notify_user "Invalid filepath: '$filepath' ends with a '/'. Please provide a filename, not a directory."
      exit 1
    fi

    # Extract filename
    filename="${filepath##*/}"

    # Determine output directory
    if [[ "$filepath" == */* ]]; then
      out_dir="${filepath%/*}"
      [[ -z "$out_dir" ]] && out_dir="/"
    else
      out_dir="."
    fi
  else
    # No filepath supplied â†’ generate filename
    filename="peck-$timestamp"
    if [[ "$mode" == "record" ]]; then
      out_dir="$PECK_RECORDING_DIR"
    else
      out_dir="$PECK_SCREENSHOT_DIR"
    fi
  fi

  # Normalize filename extension

  if [[ "$filename" == *."$out_format" ]]; then
    filename="${filename%."$out_format"}"
  fi

  # Temp file

  tmp_dir="/tmp/peck/out"
  mkdir -p "$tmp_dir"

  tmp_file="$tmp_dir/$filename.$out_format"
  out_file="$tmp_file"

  # Screenshot

  if [[ "$mode" == "screenshot" ]]; then
    grim -t "$out_format" -g "$(slurp)" "$tmp_file"

    if [[ "$mode_save" == "permanent" ]]; then
      mkdir -p "$out_dir"
      out_file="$out_dir/$filename.$out_format"
      mv "$tmp_file" "$out_file"
    fi
    notification_message="Screenshot captured ($out_file)"

    if [[ "$copy_to_clipboard" == "true" ]]; then
      wl-copy < "$out_file"
      notification_message+=" and copied to the clipboard."
    fi

    notify_user "$notification_message"

    exit 0
  fi

  # Screen Recording

  if [[ "$mode" == "record" ]]; then
    tmp_mp4="$tmp_dir/$filename.mp4"
    out_file="$tmp_mp4"

    # Ask slurp for a region if needed
    region="$(slurp 2>/dev/null)"
    if [[ -z "$region" ]]; then
      notify_user "No region selected. Exiting."
      exit 1
    fi

    # Touch a temp file so the next peck call knows to stop recording
    touch /tmp/peck/recording
    notify_user "Recording has started..." "$PECK_SILENCE_START_RECORDING"
    # Separate echo for when running from the terminal
    echo "Press CTRL+C to stop..." >&2

    wf-recorder -g "$region" -f "$tmp_mp4" &>/dev/null
    rm -f /tmp/peck/recording

    video_filter="${args[--filter]}"
    # Convert to desired output format if different from mp4
    if [[ "$out_format" != "mp4" ]]; then
      final_file="$tmp_dir/$filename.$out_format"

      # Determine which filter to use
      if [[ -n "$video_filter" ]]; then
        vf="$video_filter"
      elif [[ "$out_format" == "gif" ]]; then
        vf="fps=20,scale=iw:-1:flags=lanczos"
      else
        vf=""
      fi

      # Run ffmpeg with or without a video filter
      if [[ -n "$vf" ]]; then
        ffmpeg -y -i "$tmp_mp4" -vf "$vf" "$final_file" &>/dev/null
      else
        ffmpeg -y -i "$tmp_mp4" "$final_file" &>/dev/null
      fi

      rm -f "$tmp_mp4"
      out_file="$final_file"
    fi

    if [[ "$mode_save" == "permanent" ]]; then
      mkdir -p "$out_dir"
      final_out="$out_dir/$filename.$out_format"
      mv "$out_file" "$final_out"
      out_file="$final_out"
    fi

    notification_message="Recording captured ($out_file)"

    if [[ "$copy_to_clipboard" == "true" ]]; then
      wl-copy --type text/uri-list "file://$out_file"
      notification_message+=" and copied to the clipboard."
    fi

    notify_user "$notification_message"
  fi

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
peck_usage() {
  printf "peck - Screenshot and screen recorder tool for Wayland.\n\n"

  printf "%s\n" "Usage:"
  printf "  peck [FILEPATH] [OPTIONS]\n"
  printf "  peck --help | -h\n"
  printf "  peck --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--clipboard, -c"
    printf "    Copy the output file to the clipboard.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--record, -r"
    printf "    Record rather than screenshot.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--temp, -t"
    printf "    Store the file in /tmp/.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--format, -f FILE_FORMAT"
    printf "    Override the output format set by \$PECK_SCREENSHOT_FORMAT or\n    \$PECK_RECORDING_FORMAT. Accepts png|ppm|jpeg and mp4|gif . Other ffmpeg\n    formats that do not need filters may be supported.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filter, -F VIDEO_FILTER"
    printf "    Supply custom filter format to ffmpeg used for conversion of mp4 to the\n    desired format set with --format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FILEPATH"
    printf "    Filepath to save to\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_DIR"
    printf "    The directory to store screenshots to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Pictures"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_DIR"
    printf "    The directory to store recordings to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Recordings"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_FORMAT"
    printf "    Output to convert the screenshot to. Accepts png|ppm|jpeg.\n"
    printf "    %s\n" "Default: png"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_FORMAT"
    printf "    Output to convert the recording to. Will always record to mp4 first, and\n    then use ffmpeg to convert to the desired format.\n"
    printf "    %s\n" "Default: mp4"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SILENCE_NOTIFICATIONS"
    printf "    Determines whether peck will send a notification using libnotify.\n"
    printf "    %s\n" "Default: false"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SILENCE_START_RECORDING"
    printf "    Determines whether peck will send a notification when recording has started.\n"
    printf "    %s\n" "Default: false"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/notify_user.sh
notify_user() {
  local message="$1"
  local silence_this_notification="$2"
  echo "$message" >&2
  command -v notify-send >/dev/null 2>&1 || return 0
  [[ "$PECK_SILENCE_NOTIFICATIONS" == "true" ]] && return 0
  [[ "$silence_this_notification" == "true" ]] && return 0
  notify-send "Peck" "$message"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        peck_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"
  export PECK_SILENCE_NOTIFICATIONS="${PECK_SILENCE_NOTIFICATIONS:-false}"
  export PECK_SILENCE_START_RECORDING="${PECK_SILENCE_START_RECORDING:-false}"

  env_var_names+=("PECK_SCREENSHOT_DIR")
  env_var_names+=("PECK_RECORDING_DIR")
  env_var_names+=("PECK_SCREENSHOT_FORMAT")
  env_var_names+=("PECK_RECORDING_FORMAT")
  env_var_names+=("PECK_SILENCE_NOTIFICATIONS")
  env_var_names+=("PECK_SILENCE_START_RECORDING")

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --clipboard | -c)

        # :flag.case_no_arg
        args['--clipboard']=1
        shift
        ;;

      # :flag.case
      --record | -r)

        # :flag.case_no_arg
        args['--record']=1
        shift
        ;;

      # :flag.case
      --temp | -t)

        # :flag.case_no_arg
        args['--temp']=1
        shift
        ;;

      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FILE_FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filter | -F)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter, -F VIDEO_FILTER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['filepath']+x} ]]; then
          args['filepath']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"
  export PECK_SILENCE_NOTIFICATIONS="${PECK_SILENCE_NOTIFICATIONS:-false}"
  export PECK_SILENCE_START_RECORDING="${PECK_SILENCE_START_RECORDING:-false}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
