#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # shellcheck disable=SC2154,SC2034

  RECORDER_PID_FILE="/tmp/peck/wf-recorder.pid"

  # Ensure dependencies are installed, otherwise quit.
  dependency_check

  # Check if PID file exists and process is running wf-recorder
  if [[ -f "$RECORDER_PID_FILE" ]]; then
      recorder_pid=$(<"$RECORDER_PID_FILE")

      if ! ps -p "$recorder_pid" -o comm= | grep -qx "wf-recorder"; then
          # PID is either not running anymore, or doesn't belong to wf-recorder
          # so remove the stale file
          rm -f "$RECORDER_PID_FILE"
      else
          # Kill the wf-recorder and exit
          kill -int "$recorder_pid"
          rm -f "$RECORDER_PID_FILE"
          exit 0
      fi
  fi

  # Remove captures stored in temporary mode
  rm -rf /tmp/peck/out

  # Determine mode: screenshot or record
  mode=$([[ "${args[--record]}" == "1" ]] && echo "record" || echo "screenshot")
  # Determine save type: temporary or permanent
  mode_save=$([[ "${args[--temp]}" == "1" ]] && echo "temporary" || echo "permanent")
  # Determine if final file should be copied to clipboard
  copy_to_clipboard=$([[ "${args[--clipboard]}" == "1" ]] && echo "true" || echo "false")

  # Validate temp mode
  if [[ "$mode_save" == "temporary" && -n "${args[filepath]}" ]]; then
      notify_user "Invalid usage: --temp flag cannot be used when providing a filepath."
      exit 1
  fi

  # Determine format
  arg_format="${args[--format]}"
  if [[ -n "$arg_format" ]]; then
      out_format="$arg_format"
  else
      out_format=$([[ "$mode" == "record" ]] && echo "$PECK_RECORDING_FORMAT" || echo "$PECK_SCREENSHOT_FORMAT")
  fi

  # Generate output filepath
  filepath="${args[filepath]}"
  timestamp="$(date +%Y-%m-%d_%H-%M-%S)"
  if [[ -n "$filepath" ]]; then
      [[ "$filepath" == */ ]] && { notify_user "Invalid filepath: ends with /"; exit 1; }
      filename="$(basename "$filepath")"
      out_dir="$(dirname "$filepath")"
  else
      filename="peck-$timestamp"
      out_dir=$([[ "$mode" == "record" ]] && echo "$PECK_RECORDING_DIR" || echo "$PECK_SCREENSHOT_DIR")
  fi

  filename="${filename%."$out_format"}"

  # Create temp directory
  tmp_dir="/tmp/peck/out"
  mkdir -p "$tmp_dir"
  tmp_file="$tmp_dir/$filename.$out_format"

  # Select region
  region=$(slurp) || { notify_user "Selection cancelled, not capturing."; exit 0; }

  # Capture
  if [[ "$mode" == "screenshot" ]]; then
      grim -t "$out_format" -g "$region" "$tmp_file"
  else
      tmp_mp4="$tmp_dir/$filename.mp4"

      # Enable job control
      set -m

      notify_user "Recording has started..." "$PECK_SILENCE_START_RECORDING"
      echo "Press CTRL+C to stop recording." >&2

      # Trap SIGINT so we can CTRL+C wf-recorder
      trap "" SIGINT

      # Start wf-recorder and store its PID (in case we stop recording by rerunning peck)
      wf-recorder -g "$region" -f "$tmp_mp4" &>/dev/null &
      recorder_pid=$!
      echo "$recorder_pid" > "$RECORDER_PID_FILE"

      # Restore SIGINT handling for child
      trap - SIGINT

      # Bring recorder to foreground (so CTRL+C hits only wf-recorder)
      fg %- >/dev/null

      # Remove the PID file in case we stopped recording by CTRL+C rather than rerunning peck
      rm -f "$RECORDER_PID_FILE"

      # Handle conversion/filtering
      video_filter="${args[--filter]}"
      if [[ "$out_format" != "mp4" || -n "$video_filter" ]]; then
          vf="$video_filter"
          [[ -z "$vf" && "$out_format" == "gif" ]] && vf="fps=20,scale=iw:-1:flags=lanczos"

          if [[ -n "$vf" ]]; then
              ffmpeg -y -i "$tmp_mp4" -vf "$vf" "$tmp_file" &>/dev/null
          else
              ffmpeg -y -i "$tmp_mp4" "$tmp_file" &>/dev/null
          fi

          rm -f "$tmp_mp4"
      else
          tmp_file="$tmp_mp4"
      fi
  fi

  final_path="$tmp_file"

  # Move to permanent location if needed
  if [[ "$mode_save" == "permanent" ]]; then
      mkdir -p "$out_dir"
      final_path="$out_dir/$filename.$out_format"
      mv "$tmp_file" "$final_path"
  fi

  # Notify and copy to clipboard if requested
  notification_message="Captured ($final_path)"
  if [[ "$copy_to_clipboard" == "true" ]]; then
      if [[ "$mode" == "screenshot" ]]; then
          wl-copy < "$final_path"
      else
          wl-copy --type text/uri-list "file://$final_path"
      fi
      notification_message+=" and copied to clipboard."
  fi

  notify_user "$notification_message"

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
peck_usage() {
  printf "peck - Screenshot and screen recorder tool for Wayland.\n\n"

  printf "%s\n" "Usage:"
  printf "  peck [FILEPATH] [OPTIONS]\n"
  printf "  peck --help | -h\n"
  printf "  peck --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--clipboard, -c"
    printf "    Copy the output file to the clipboard.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--record, -r"
    printf "    Record rather than screenshot.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--temp, -t"
    printf "    Store the file in /tmp/.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--format, -f FILE_FORMAT"
    printf "    Override the output format set by \$PECK_SCREENSHOT_FORMAT or\n    \$PECK_RECORDING_FORMAT. Accepts png|ppm|jpeg and mp4|gif . Other ffmpeg\n    formats that do not need filters may be supported.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filter, -F VIDEO_FILTER"
    printf "    Supply custom filter format to ffmpeg used for conversion of mp4 to the\n    desired format set with --format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FILEPATH"
    printf "    Filepath to save to\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_DIR"
    printf "    The directory to store screenshots to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Pictures"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_DIR"
    printf "    The directory to store recordings to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Recordings"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_FORMAT"
    printf "    Output to convert the screenshot to. Accepts png|ppm|jpeg.\n"
    printf "    %s\n" "Default: png"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_FORMAT"
    printf "    Output to convert the recording to. Will always record to mp4 first, and\n    then use ffmpeg to convert to the desired format.\n"
    printf "    %s\n" "Default: mp4"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SILENCE_NOTIFICATIONS"
    printf "    Determines whether peck will send a notification using libnotify.\n"
    printf "    %s\n" "Default: false"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SILENCE_START_RECORDING"
    printf "    Determines whether peck will send a notification when recording has started.\n"
    printf "    %s\n" "Default: false"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/dependency_check.sh
dependency_check() {
  for cmd in grim slurp wf-recorder ffmpeg wl-copy; do
    command -v "$cmd" >/dev/null 2>&1 || {

        echo "Error: $cmd not found. Please install: grim, slurp, wf-recorder, ffmpeg, and wl-copy." >&2
        exit 1
    }
  done
}

# src/lib/notify_user.sh
notify_user() {
  local message="$1"
  local silence_this_notification="$2"
  echo "$message" >&2
  command -v notify-send >/dev/null 2>&1 || return 0
  [[ "$PECK_SILENCE_NOTIFICATIONS" == "true" ]] && return 0
  [[ "$silence_this_notification" == "true" ]] && return 0
  notify-send "Peck" "$message"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        peck_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"
  export PECK_SILENCE_NOTIFICATIONS="${PECK_SILENCE_NOTIFICATIONS:-false}"
  export PECK_SILENCE_START_RECORDING="${PECK_SILENCE_START_RECORDING:-false}"

  env_var_names+=("PECK_SCREENSHOT_DIR")
  env_var_names+=("PECK_RECORDING_DIR")
  env_var_names+=("PECK_SCREENSHOT_FORMAT")
  env_var_names+=("PECK_RECORDING_FORMAT")
  env_var_names+=("PECK_SILENCE_NOTIFICATIONS")
  env_var_names+=("PECK_SILENCE_START_RECORDING")

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --clipboard | -c)

        # :flag.case_no_arg
        args['--clipboard']=1
        shift
        ;;

      # :flag.case
      --record | -r)

        # :flag.case_no_arg
        args['--record']=1
        shift
        ;;

      # :flag.case
      --temp | -t)

        # :flag.case_no_arg
        args['--temp']=1
        shift
        ;;

      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FILE_FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filter | -F)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter, -F VIDEO_FILTER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['filepath']+x} ]]; then
          args['filepath']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"
  export PECK_SILENCE_NOTIFICATIONS="${PECK_SILENCE_NOTIFICATIONS:-false}"
  export PECK_SILENCE_START_RECORDING="${PECK_SILENCE_START_RECORDING:-false}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
