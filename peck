#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # shellcheck disable=SC2154,SC2034

  if [[ "${args[--stop]}" == "1" ]]; then
    echo "STOPPING"
    pkill -INT -x wf-recorder
    notify-send "Peck" "Recording stopped $DBUS_SESSION_BUS_ADDRESS"
    exit 0
  fi

  # --- Mode ----------------------------------------------------

  if [[ "${args[--record]}" == "1" ]]; then
    mode="record"
  else
    mode="screenshot"
  fi

  # --- Save location -------------------------------------------

  if [[ "${args[--temp]}" == "1" ]]; then
    if [[ -n "${args[filepath]}" ]]; then
  	  echo "Argument mismatch: --temp flag cannot be used when providing a filepath." >&2
  	  exit 1
    fi
    mode_save="temporary"
  else
    mode_save="permanent"
  fi

  # --- Clipboard ------------------------------------------------

  if [[ "${args[--clipboard]}" == "1" ]]; then
    copy_to_clipboard="yes"
  else
    copy_to_clipboard="no"
  fi

  # --- Format ---------------------------------------------------

  arg_format="${args[--format]}"

  if [[ -n "$arg_format" ]]; then
    out_format="$arg_format"
  elif [[ "$mode" == "record" ]]; then
    out_format="$PECK_RECORDING_FORMAT"
  else
    out_format="$PECK_SCREENSHOT_FORMAT"
  fi

  # --- Path resolution -----------------------------------------

  filepath="${args[filepath]}"
  timestamp="$(date +%Y-%m-%d_%H-%M-%S)"

  if [[ -n "$filepath" ]]; then
    filename="${filepath##*/}"

    if [[ "$filepath" == */* ]]; then
      out_dir="${filepath%/*}"
      [[ -z "$out_dir" ]] && out_dir="/"
    else
      out_dir="."
    fi
  else
    filename="peck-$timestamp"
    if [[ "$mode" == "record" ]]; then
      out_dir="$PECK_RECORDING_DIR"
    else
      out_dir="$PECK_SCREENSHOT_DIR"
    fi
  fi

  # --- Normalize filename extension ----------------------------

  if [[ "$filename" == *."$out_format" ]]; then
    filename="${filename%."$out_format"}"
  fi

  # --- Temp file -----------------------------------------------

  tmp_dir="/tmp/peck"
  mkdir -p "$tmp_dir"

  tmp_file="$tmp_dir/$filename.$out_format"
  out_file="$tmp_file"

  # --- Screenshot ----------------------------------------------

  if [[ "$mode" == "screenshot" ]]; then
    grim -t "$out_format" -g "$(slurp)" "$tmp_file"

    if [[ "$mode_save" == "permanent" ]]; then
      mkdir -p "$out_dir"
      out_file="$out_dir/$filename.$out_format"
      mv "$tmp_file" "$out_file"
    fi
    echo "Screenshot captured and stored at '$out_file'" >&2

    if [[ "$copy_to_clipboard" == "yes" ]]; then
      wl-copy < "$out_file"
      echo "Screenshot was copied to the clipboard." >&2
    fi
  fi

  # --- Screen Recording ----------------------------------------

  if [[ "$mode" == "record" ]]; then
    tmp_mp4="$tmp_dir/$filename.mp4"
    out_file="$tmp_mp4"

    # Ask slurp for a region if needed
    region="$(slurp 2>/dev/null)"
    if [[ -z "$region" ]]; then
      echo "No region selected. Exiting." >&2
      exit 1
    fi

    echo "Recording screen. Press Ctrl+C to stop..." >&2
    wf-recorder -g "$region" -f "$tmp_mp4" &>/dev/null

    # Convert to desired output format if different from mp4
    if [[ "$out_format" != "mp4" ]]; then
      final_file="$tmp_dir/$filename.$out_format"

      if [[ "$out_format" == "gif" ]]; then
        ffmpeg -y -i "$tmp_mp4" -vf "fps=15,scale=iw:-1:flags=lanczos" "$final_file" &>/dev/null
      else
        ffmpeg -y -i "$tmp_mp4" "$final_file" &>/dev/null
      fi

      rm -f "$tmp_mp4"
      out_file="$final_file"
    fi

    if [[ "$mode_save" == "permanent" ]]; then
      mkdir -p "$out_dir"
      final_out="$out_dir/$filename.$out_format"
      mv "$out_file" "$final_out"
      out_file="$final_out"
    fi

    echo "Recording saved at '$out_file'" >&2

    if [[ "$copy_to_clipboard" == "yes" ]]; then
      if [[ "$out_format" == "gif" ]]; then
        wl-copy < "$out_file"
      else
        echo "Clipboard copy is only supported for images." >&2
      fi
    fi
  fi

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
peck_usage() {
  printf "peck - Screenshot and screen recorder tool for Wayland.\n\n"

  printf "%s\n" "Usage:"
  printf "  peck [FILEPATH] [OPTIONS]\n"
  printf "  peck --help | -h\n"
  printf "  peck --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--clipboard, -c"
    printf "    Copy the output file to the clipboard.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--record, -r"
    printf "    Record rather than screenshot.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--temp, -t"
    printf "    Store the file in /tmp/.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--format, -f FILE_FORMAT"
    printf "    Override the output format set by \$PECK_SCREENSHOT_FORMAT or\n    \$PECK_RECORDING_FORMAT. Accepts png|ppm|jpeg\n"
    echo

    # :flag.usage
    printf "  %s\n" "--stop, -s"
    printf "    Stop recording (Kills wf-record process).\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FILEPATH"
    printf "    Filepath to save to\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_DIR"
    printf "    The directory to store screenshots to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Pictures"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_DIR"
    printf "    The directory to store recordings to when no filepath is provided. Will\n    create this if it does not exist. Overridden by [--temp | -t]\n"
    printf "    %s\n" "Default: $HOME/Recordings"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_SCREENSHOT_FORMAT"
    printf "    Output to convert the screenshot to. Accepts png|ppm|jpeg.\n"
    printf "    %s\n" "Default: png"
    echo

    # :environment_variable.usage
    printf "  %s\n" "PECK_RECORDING_FORMAT"
    printf "    Output to convert the recording to. Will always record to mp4 first, and\n    then use ffmpeg to convert to the desired format.\n"
    printf "    %s\n" "Default: mp4"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        peck_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"

  env_var_names+=("PECK_SCREENSHOT_DIR")
  env_var_names+=("PECK_RECORDING_DIR")
  env_var_names+=("PECK_SCREENSHOT_FORMAT")
  env_var_names+=("PECK_RECORDING_FORMAT")

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --clipboard | -c)

        # :flag.case_no_arg
        args['--clipboard']=1
        shift
        ;;

      # :flag.case
      --record | -r)

        # :flag.case_no_arg
        args['--record']=1
        shift
        ;;

      # :flag.case
      --temp | -t)

        # :flag.case_no_arg
        args['--temp']=1
        shift
        ;;

      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FILE_FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --stop | -s)

        # :flag.case_no_arg
        args['--stop']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['filepath']+x} ]]; then
          args['filepath']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # :command.environment_variables_default
  export PECK_SCREENSHOT_DIR="${PECK_SCREENSHOT_DIR:-$HOME/Pictures}"
  export PECK_RECORDING_DIR="${PECK_RECORDING_DIR:-$HOME/Recordings}"
  export PECK_SCREENSHOT_FORMAT="${PECK_SCREENSHOT_FORMAT:-png}"
  export PECK_RECORDING_FORMAT="${PECK_RECORDING_FORMAT:-mp4}"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
